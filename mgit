#!/bin/bash
shopt -s nullglob
IFS=$'\n\b'

usage() {
	[ "$1" ] && {
		echo
		echo "ERROR: $1"
		echo
		exit
	}
	echo
	echo " multigit 1.0 - git wrapper for working with overlaid repos."
	echo " Cosmin Apreutesei | public domain | https://github.com/capr/multigit"
	echo
	echo " USAGE: $0 ..."
	echo
	echo "   ls                           list cloned repos"
	echo "   ls-all                       list all known repos"
	echo "   ls-uncloned                  list all known but not cloned repos"
	echo
	echo "   ls-modified                  list files that were modified locally"
	echo "   ls-unpushed                  list repos that are ahead of origin"
	echo "   ls-untracked                 list files untracked by any repo"
	echo "   ls-double-tracked            list files tracked by multiple repos"
	echo
	echo "   init REPO [git-init-options...]        create a local repo"
	echo "   clone [REMOTE/]REPO|URL[=version] ...  clone one ore more repos"
	echo "   clone-all [git-fetch-options]          clone all known uncloned repos"
	echo "   remove [--dry] REPO ...                remove cloned repos from disk (!)"
	echo
	echo "   baseurl [REMOTE [URL|-]]     get/set/delete the baseurl of a remote"
	echo "   origin [REPO [REMOTE|URL|-]] get/set/delete the known origin of a repo"
	echo
	echo "   REPO                         start a shell for using git on a repo"
	echo "   REPO|--all command ...       execute any git command on a repo"
	echo "   REPO|--all exec ...          execute a shell command in a repo context"
	echo
	echo "   REPO|--all up [MESSAGE]      add/commit/push combo"
	echo "   REPO|--all bump              bump version and push tags"
	echo "   REPO|--all uptag             update tag (!) and push tags"
	echo "   REPO|--all ver[sion]         show repo version (enum or list)"
	echo "   REPO|--all clear-history     clear the history of the current branch (!)"
	echo "   REPO|--all update-perms      git-chmod +x all .sh files in repo"
	echo
	echo "   REPO|--all make-symlinks     make symbolic links in .multigit/REPO"
	echo "   REPO|--all make-hardlinks    make hard links in .multigit/REPO"
	echo
	echo "   release [REL]                show a release or list releases"
	echo "   release REL update           create/update a release based on HEADs"
	echo "   release REL checkout         clone/checkout repos from a release"
	echo
	echo "   [help|--help]                show this screen"
	echo
	exit
}

check_root() { [ -d .multigit ] || usage "\".multigit\" dir not found."; }

list_known() {
	check_root
	(cd .multigit && \
	for f in *.origin; do
		echo "${f%.origin}"
	done)
}

list_cloned() {
	check_root
   (cd .multigit && \
	for f in *; do
		[ -d "$f/.git" ] && echo "$f"
	done)
}

list_uncloned() {
	check_root
	(cd .multigit && \
	for f in *.origin; do
		f="${f%.origin}"
		[ ! -d "$f/.git" ] && echo $f
	done)
}

list_modified() {
	check_root
	git_cmd_all status -s
}

list_unpushed() {
	check_root
	for repo in `list_cloned`; do
		[ "$(GIT_DIR=".multigit/$repo/.git" \
				git rev-list HEAD...origin/master --count 2>/dev/null)" \
			!= "0" ] && echo "$repo"
	done
}

tracked_files() {
	check_root
	([ -d .git ] && git ls-files
	for repo in `list_cloned`; do
		GIT_DIR=".multigit/$repo/.git" git ls-files
	done) | sort | uniq $1
}

existing_files() {
	find * -type f | sort | uniq
}

list_untracked() {
	check_root
	comm -23 <(existing_files) <(tracked_files)
}

list_double_tracked() {
	check_root
	for repo in `list_cloned`; do
		GIT_DIR=".multigit/$repo/.git" git ls-files | while read f; do
			printf "%-16s %s\n" "$repo" "$f"
		done
	done | grep -F -w -f <(tracked_files -d)
}

clone_all() {
	export MULTIGIT_FETCH_OPTS="$@"
	for repo in `list_uncloned`; do
		"$0" clone "$repo"
	done
}

init() {
	local name="$1"
	name="${name//[[:blank:]]/}" # spaces not allowed
	[ "$name" = "$1" ] || usage "Invalid name \"$1\"."
	shift

	# check that the repo is not already cloned
	[ -d ".multigit/$name" ] && {
		echo "SKIPPING: Already exists: \"$name\"."
		return 1
	}

	mkdir -p ".multigit/$name"
	export GIT_DIR=".multigit/$name/.git"
	git init "$@"
	git config --local core.worktree ../../..

	# make a default "exclude-all" exclude file
	git config --local core.excludesfile ".multigit/$name.exclude"
	[ -f ".multigit/$name.exclude" ] || echo '*' > ".multigit/$name.exclude"

	return 0
}

clone_one() {
	local arg="$1"
	local name
	local origin
	local rorigin
	local url
	local ver

	arg="${arg//[[:blank:]]/}" # spaces not allowed
	[ "$arg" = "$1" ] || usage "Invalid name \"$name\"."

	# extract `=version` if any
	ver="${arg##*=}"
	[ "$ver" == "$arg" ] && ver=""
	arg="${arg%=*}"

	# check if the arg is a full url or just `[origin/]name`
	if [ "${arg#*:}" != "$arg" ]; then
		url="$arg"
		origin="$arg"
		name="${url##*/}"
		name="${name%.git}"
	else
		name="${arg##*/}"
		origin="${arg%/*}"
		[ "$origin" = "$arg" ] && origin=""
	fi

	# check that arg is not `/` or `origin/`
	[ "$name" ] || usage "Invalid repo name \"$1\"."

	# check for a registered origin
	[ -f ".multigit/$name.origin" ] && \
		rorigin=$(cat .multigit/$name.origin)

	# decide the origin
	if [ "$origin" ]; then
		[ "$rorigin" -a "$origin" != "$rorigin" ] && \
			echo "NOTE:  Using different origin for \"$name\": \"$origin\" (was \"$rorigin\")."
	else
		origin="$rorigin"
		[ "$origin" ] || {
			echo "SKIPPING: Unknown repo \"$name\"."
			return
		}
	fi

	# find the origin url
	if [ ! "$url" ]; then
		if [ -f ".multigit/$origin.baseurl" ]; then
			local baseurl=$(cat .multigit/$origin.baseurl)
			url="$baseurl$name"
		else
			# assume the origin on file is a full url: check if it is
			if [ "${origin#*:}" != "$origin" ]; then
				url="$origin"
			else
				echo "ERROR: Unknown origin: \"$origin\" for \"$name\"."
				echo "HINT:  To register \"$origin\" to be used as an origin, type, eg.:"
				echo "HINT:    "$(basename "$0")" baseurl $origin https://github.com/$origin/"
				return
			fi
		fi
	fi

	# finally, clone the repo
	init "$name" || return
	git remote add origin "$url"
	git fetch $MULTIGIT_FETCH_OPTS || {
		rm -rf ".multigit/$name/"
		rm ".multigit/$name.exclude"
		echo "ERROR: Fetch failed. Repo removed."
		return
	}
	git branch --track master origin/master
	local branch="$ver"; [ "$branch" ] || branch=master
	git checkout -B $branch $ver

	# if fetch was successful, (re)register the repo's origin
	if [ "$origin" != "$rorigin" ]; then
		if [ "$rorigin" ]; then
			echo "NOTE:  Updating origin for \"$name\": \"$origin\" (was \"$rorigin\")"
		else
			echo "NOTE:  Adding origin for \"$name\": \"$origin\" (url: \"$url\")"
		fi
		mkdir -p .multigit
		echo "$origin" > ".multigit/$name.origin"
	fi
}

clone() {
	[ "$1" ] || usage "Repo name expected."
	if [ $# = 1 ]; then
		clone_one "$@"
	else
		while [ $# != 0 ]; do
	   	clone_one "$1"
	   	shift
	   done
	fi
}

run() { if [ "$DRY_RUN" ]; then echo "$@"; else "$@"; fi; }

remove_one() {
	[ "$1" ] || usage "Invalid name \"$1\"."

	[ -d ".multigit/$1/" ] || {
		echo "ERROR: Repo not found \"$1\"."
		return
	}

	# don't remove from a subshell
	[ "$MULTIGIT_REPO" == "$1" ] && \
		usage "Refusing to remove \"$1\" from a subshell."

	# get tracked files for this repo
	files="$(GIT_DIR=".multigit/$1/.git" git ls-files)" || {
		echo "ERROR: Could not get the list of files for \"$1\"."
		echo "HINT:  If you know that there are no checked out files,"
		echo "HINT:  feel free to \`rm -rf .multigit/$1/ .multigit/$1.exclude\`."
		return
	}

	# remove files
	for file in $files; do
		run rm "$file"
	done

	# remove empty directories
	for file in $files; do
		echo "$(dirname "$file")"
	done | uniq | while read dir; do
		[ "$dir" != "." ] && run /bin/rmdir -p "$dir" 2>/dev/null
	done

	# remove the git dir
	run rm -rf ".multigit/$1/"
	run rm -f "$1.exclude"

	echo "Removed: \"$1\"."
}

remove() {
	[ "$1" = "--dry" ] && { DRY_RUN=1; shift; }
	[ "$1" ] || usage "Repo name expected."
	if [ $# = 1 ]; then
		remove_one "$@"
	else
		while [ $# != 0 ]; do
	   	remove_one "$1"
	   	shift
	   done
	fi
}

baseurl() {
	[ "$1" ] || {
		for f in .multigit/*.baseurl; do
			f="${f#.multigit/}"
			f="${f%.baseurl}"
			printf "%-20s %s\n" "$f" "$(baseurl "$f")"
		done
		return
	}
	local origin="$1"
	local url="$2"
	# spaces not allowed
	origin="${origin//[[:blank:]]/}"
	url="${url//[[:blank:]]/}"
	[ -z "$1" -o "$1" != "$origin" ] && usage "Invalid origin name \"$1\"."
	[ "$2" -a "$2" != "$url" ] && usage "Invalid baseurl \"$2\"."

	if [ "X$url" = "X-" ]; then
		rm ".multigit/$origin.baseurl"
	elif [ "$url" ]; then
		[ "${url##*/}" != "" ] && usage "A base URL must end with a '/'."
		mkdir -p .multigit
		echo "$url" > ".multigit/$origin.baseurl"
	else
		cat ".multigit/$origin.baseurl"
	fi
}

origin() {
	[ "$1" ] || {
		for f in .multigit/*.origin; do
			f="${f#.multigit/}"
			f="${f%.origin}"
			printf "%-20s %s\n" "$f" "$(origin "$f")"
		done
		return
	}
	local repo="$1"
	local origin="$2"

	# spaces not allowed
	repo="${repo//[[:blank:]]/}"
	origin="${origin//[[:blank:]]/}"
	[ -z "$1" -o "$1" != "$repo" ] && usage "Invalid repo name \"$1\"."
	[ "$2" -a "$2" != "$origin" ] && usage "Invalid origin \"$2\"."

	if [ "X$origin" = "X-" ]; then
		rm ".multigit/$repo.origin"
	elif [ "$origin" ]; then
		mkdir -p .multigit
		echo "$origin" > ".multigit/$repo.origin"
	else
		cat ".multigit/$repo.origin"
	fi
}

list_releases() {
	for f in .multigit/*.release; do
		f="${f#.multigit/}"
		f="${f%.release}"
		echo "$f"
	done
}

show_release() {
	[ -f ".multigit/$1.release" ] || usage "Unknown release \"$1\"."
	cat ".multigit/$1.release"
}

update_release() {
	"$0" --all version > ".multigit/$1.release"
}

checkout_release() {
	local repo="$1"
	[ -f ".multigit/$repo.release" ] || usage "Unknown release \"$repo\"."
	cat ".multigit/$repo.release" | (IFS=" "; while read repo ver; do
		[ -d ".multigit/$repo/.git" ] || "$0" clone "$repo"
		local branch="$ver"; [ "$branch" ] || branch=master
		"$0" "$repo" checkout -B "$branch" "$ver"
	done)
}

release() {
	local rel="$1"
	rel="${rel//[[:blank:]]/}" # spaces not allowed
	[ "$rel" -a "$1" != "$rel" ] && usage "Invalid release name \"$1\"."
	[ "$rel" ] || { list_releases; return; }
	case "$2" in
		"")       show_release "$rel" ;;
		update)   update_release "$rel" ;;
		checkout) checkout_release "$rel" ;;
		*)        usage "Invalid release commnad \"$2\"."
	esac
}

git_shell() {
	echo "Entering subshell: git commands will affect the repo \"$MULTIGIT_REPO\"."
	echo "Type \`exit' to exit subshell."
	git status -s
	echo
	if [ "$OSTYPE" = "msys" ]; then
		export PROMPT="[$MULTIGIT_REPO] \$P\$G"
		exec "$COMSPEC" /k
	else
		export PS1="[$MULTIGIT_REPO] \u@\h:\w\$ "
		exec "$SHELL" -i
	fi
}

git_up() {
	msg="$1"
	[ "$msg" ] || msg="unimportant"
	git add -A
	git commit -m "$msg"
	git push
}

git_bump() {
	local tag="$(git describe --tags --abbrev=0 2>/dev/null)"
	[ "$tag" ] || tag="0"
	local n=$((tag+0))
	[ "$n" == "$tag" ] || usage "Tag \"$tag\" is not a number."
	tag=$((tag+1))
	git tag -f "$tag"
	git push -f --tags
}

git_uptag() {
	local tag="$(git describe --tags --abbrev=0 2>/dev/null)"
	[ "$tag" ] || usage "No current tag to update. Make a tag first."
	git tag -f "$tag"
	git push -f --tags
}

git_ver() {
	printf "$MULTIGIT_REPO=$(git describe --tags --long --always) "
	[ "$ALL" ] || echo
}

git_version() {
	printf "%-20s" "$MULTIGIT_REPO"
	git describe --tags --long --always
}

git_clear_history() {
	local branch="$(git rev-parse --abbrev-ref HEAD)"
	git checkout --orphan delete_me
	git add -A
	git commit -m "init (history cleared)"
	git branch -D "$branch"
	git branch -m "$branch"
}

git_update_perms() {
	git ls-files | \
		while read f; do
			[ "${f##*.}" = "sh" ] && \
				git update-index --chmod=+x "$f"
		done
}

git_remove_links() {
	[ "$OSTYPE" = "msys" ] && usage "Not for Windows."
	([ "$MULTIGIT_REPO" ] && cd ".multigit/$MULTIGIT_REPO" || exit 1
	find . ! -path './.git/*' ! -path './.git' ! -path '.' -exec rm -rf {} \; 2>/dev/null)
}
git_make_hardlinks() {
	git_remove_links
	git ls-files | while read f; do
		mkdir -p "$(dirname ".multigit/$MULTIGIT_REPO/$f")"
		ln -f "$f" ".multigit/$MULTIGIT_REPO/$f"
	done
}
git_make_symlinks() {
	git_remove_links
	git ls-files | while read f; do
		mkdir -p "$(dirname ".multigit/$MULTIGIT_REPO/$f")"
		ln -sf "$PWD/$f" ".multigit/$MULTIGIT_REPO/$f"
	done
}

git_cmd() {
	repo="$1"; shift
	export GIT_DIR=".multigit/$repo/.git"
	export MULTIGIT_REPO="$repo"
	[ -d "$GIT_DIR" ] || usage "Unknown repo: \"$repo\"."
	case "$1" in
		exec)           shift; "$@" ;;
		up)             git_up "$2" ;;
		uptag)          git_uptag ;;
		bump)           git_bump ;;
		ver)            git_ver ;;
		version)        git_version ;;
		clear-history)  git_clear_history ;;
		update-perms)   git_update_perms ;;
		make-symlinks)  git_make_symlinks ;;
		make-hardlinks) git_make_hardlinks ;;
		"")             git_shell ;;
		*)              git "$@" ;;
	esac
	export GIT_DIR=
	export MULTIGIT_REPO=
}

git_cmd_all() {
	for repo in `list_cloned`; do
		ALL=1 git_cmd "$repo" "$@"
	done
	[ "$1" == "ver" ] && echo
}

cd_root() {
	local pwd1
	while [ "$PWD" != "$pwd1" ]; do
		[ -d .multigit ] && return
		pwd1="$PWD"
		cd .. || usage "Could not cd to \"$PWD/..\"."
	done
	cd "$PWD0" # root dir not found, go back to initial dir
}

PWD0="$PWD"
cd_root

case "$1" in
	"")           usage ;;
	help)         usage ;;
	--help)       usage ;;
	ls)           list_cloned ;;
	ls-all)       list_known ;;
	ls-uncloned)  list_uncloned ;;
	ls-modified)  list_modified ;;
	ls-unpushed)  list_unpushed ;;
	ls-untracked) list_untracked ;;
	ls-double-tracked) list_double_tracked ;;
	init)    shift; init "$@" ;;
	clone)   shift; clone "$@" ;;
	remove)  shift; remove "$@" ;;
	baseurl) shift; baseurl "$@" ;;
	origin)  shift; origin "$@" ;;
	release) shift; release "$@" ;;
	--all)
		shift
		[ "$1" ] || usage "Refusing to start a subshell for each repo."
		git_cmd_all "$@"
		;;
	*) git_cmd "$@" ;;
esac
